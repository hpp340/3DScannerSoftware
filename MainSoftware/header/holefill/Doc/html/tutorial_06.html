<html>
    <head>
      <title>OpenMesh: Using mesh traits and attributes</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial_06">Using mesh traits and attributes</a></h1>this example shows:<p>
<ul>
<li>How to change the data type for positions, normals, colors, and texture,</li><li>How to add standard properties using traits.</li></ul>
<p>
In the previous tutorial (<a class="el" href="tutorial_05.html">Using standard properties</a>) we learned to use standard properties. Unlike the custom properties, where the user specifies the data type by passing the type to the handle (e.g. <code>MyMesh::FPropHandleT&lt;</code> <b>int</b>&gt;), the data types of the standard properties are defined by so-called mesh traits. With traits we can customize and extend the mesh data structure. We can do this by changing three important features<p>
<ol type=1>
<li>changing data type for positions, normals, colors, and texture coordinates</li><li>adding standard properties using <code><a class="el" href="namespaceOpenMesh_1_1Attributes.html">OpenMesh::Attributes</a></code>.</li><li>extend mesh entities Vertex, Face, Edge, and Halfedge (see tutorial '<a class="el" href="tutorial_07.html">Extending the mesh using traits</a>')</li></ol>
<p>
Let's start. Every custom traits should derive from the default traits<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : OpenMesh::DefaultTraits
</pre></div><p>
As mentioned, we can change the basic data types for the basic types <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#2d5544e9953addba9971e264ecf6d729">MyMesh::Normal</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#bd3f83a0fd6421c512ccc2c5b0e1cc5f">MyMesh::Color</a></code>, and <code>MyMesh::TexCoord</code>. We can use the provided vector class or we use a different one from another library. Here we simply replace the default type <code><a class="el" href="namespaceOpenMesh.html#3470a8299d88328d7019b93aef9852c2">OpenMesh::Vec3f</a></code> (defined in the <code><a class="el" href="structOpenMesh_1_1DefaultTraits.html">OpenMesh::DefaultTraits</a></code>) for positions and normals with <code><a class="el" href="namespaceOpenMesh.html#912d4fbc66341fc279a8286b5ebb0963">OpenMesh::Vec3d</a></code> <p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> Point;
  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">Normal</a>;
</pre></div><p>
(In general it's better to have the same scalar type for the point and normal vector, for instance <code>double</code> in this case. Otherwise we have to casts quite a lot depending on the implementation of the vector class.)<p>
The second feature are attributes. Using attributes allows us to do two things<p>
<ol type=1>
<li>indicate the usage of standard properties at compile time.</li><li>set special features, which influences the behaviour of the mesh.</li></ol>
<p>
Following attributes (see also <a class="el" href="namespaceOpenMesh_1_1Attributes.html">OpenMesh::Attributes</a>) are available<p>
<ul>
<li><a class="el" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a></li><li><a class="el" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc362d138c17efa0c78fef62c418953f67b8">OpenMesh::Attributes::Color</a></li><li>OpenMesh::Attributes::TexCoord</li><li><a class="el" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc365f062bb8f8043717005d54c8d480f760">OpenMesh::Attributes::Status</a></li><li><a class="el" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc3698cca64c8972265b612cb15552bc82ed">OpenMesh::Attributes::PrevHalfedge</a></li></ul>
<p>
Apparently the first four attributes control the integration of the standard properties Normal, Color, TexCoord and Status. Recall the last tutorial, where used the request-methods to have normals. Now we use the attributes to achieve the same goal<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">VertexAttributes</a>  ( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> );
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#d1f28c7308ba404416cbb8f0bf337181">FaceAttributes</a>    ( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> );
</pre></div><p>
Be aware that theses settings overwrite the ones of the parent traits class! As we usually derive from the DefaultTraits let's have a close look.<p>
Actually the struct <code><a class="el" href="structOpenMesh_1_1DefaultTraits.html">OpenMesh::DefaultTraits</a></code> is merely empty. It solely defines the types for <code>Point</code>, <code>Normal</code>, <code>TexCoord</code>, and <code>Color</code> and one attribute, that we used implicitly all the time:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::PrevHalfedge );</span>
</pre></div><p>
The attribute <code>PrevHalfedge</code> is different, as it does not control a property. Yet it has a great impact on the resulting mesh type, as it adds additional information to the halfedge structure. The impact is twofold:<p>
<ol type=1>
<li>fast access to previous halfedge</li><li>increase of memory consumption</li></ol>
<p>
Using this feature depends highly on our needs. One situation where the previous halfedges are quite handy, is the mesh member function add_face(). The execution time for the member function drops dramatically, when the information about the previous halfedge is available. Usually we want to have this information. But if not, because we must save memory, we can easily remove it with<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::None );</span>
</pre></div><p>
Then we need 8 bytes less per edge, which can be quite a lot as one can derive from the Euler formula (<img class="formulaInl" alt="$V-E+F=2 (1-g)$" src="form_0.png">), that for a regular triangle meshes with genus <img class="formulaInl" alt="$g=0$" src="form_1.png"> the number of edges <img class="formulaInl" alt="$E$" src="form_2.png">is approximately three times the number of vertices <img class="formulaInl" alt="$V$" src="form_3.png">: <img class="formulaInl" alt="$ E \approx 3 \cdot V$" src="form_4.png">.<p>
The complete source looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;typeinfo&gt;</span>
<span class="comment">// --------------------</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Math/VectorT.hh&gt;</span>


<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="comment">// Define my personal traits</span>
<span class="keyword">struct </span>MyTraits : OpenMesh::DefaultTraits
{
  <span class="comment">// let Point and Normal be a vector made from doubles</span>
  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> Point;
  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> Normal;

  <span class="comment">// add normal property to vertices and faces</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">VertexAttributes</a>  ( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> );
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#d1f28c7308ba404416cbb8f0bf337181">FaceAttributes</a>    ( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> );

  <span class="comment">// Already defined in OpenMesh::DefaultTraits</span>
  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::PrevHalfedge );</span>
  
  <span class="comment">// Uncomment next line to disable attribute PrevHalfedge</span>
  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::None );</span>
  <span class="comment">//</span>
  <span class="comment">// or</span>
  <span class="comment">//</span>
  <span class="comment">// HalfedgeAttributes( 0 );</span>
};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// Define my mesh with the new traits!</span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;

<span class="comment">// ------------------------------------------------------------------ main ----</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;

  <span class="keywordflow">if</span> (argc!=2)
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Usage: attributes &lt;input&gt;\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// just make sure that point element type is double</span>
  <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>( <a class="code" href="structOpenMesh_1_1vector__traits.html">OpenMesh::vector_traits&lt;MyMesh::Point&gt;::value_type</a> ) 
       != <span class="keyword">typeid</span>(<span class="keywordtype">double</span>) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Ouch! ERROR! Data type is wrong!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>( <a class="code" href="structOpenMesh_1_1vector__traits.html">OpenMesh::vector_traits&lt;MyMesh::Normal&gt;::value_type</a> ) 
       != <span class="keyword">typeid</span>(<span class="keywordtype">double</span>) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Ouch! ERROR! Data type is wrong!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// load a mesh</span>
  <a class="code" href="classOpenMesh_1_1IO_1_1Options.html">OpenMesh::IO::Options</a> opt;
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#d5533287a322aab83c19ea93ed626ae1">OpenMesh::IO::read_mesh</a>(mesh,argv[1], opt))
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error loading mesh from file "</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// If the file did not provide vertex normals, then calculate them</span>
  <span class="keywordflow">if</span> ( !opt.<a class="code" href="classOpenMesh_1_1IO_1_1Options.html#b29ad02b981bdf64d70f562093a8df27">check</a>( <a class="code" href="classOpenMesh_1_1IO_1_1Options.html#040ea9de4824f79bb2331a8783243247816fe76469be54841546944f847e92cd">OpenMesh::IO::Options::VertexNormal</a> ) &amp;&amp;
       mesh.has_face_normals() &amp;&amp; mesh.has_vertex_normals() )
  {
    <span class="comment">// let the mesh update the normals</span>
    mesh.update_normals();
  }

  <span class="comment">// move all vertices one unit length along it's normal direction</span>
  <span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a> v_it = mesh.vertices_begin();
       v_it != mesh.vertices_end(); ++v_it)
  {
    std::cout &lt;&lt; <span class="stringliteral">"Vertex #"</span> &lt;&lt; v_it &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; mesh.point( v_it );
    mesh.set_point( v_it, mesh.point(v_it)+mesh.normal(v_it) );
    std::cout &lt;&lt; <span class="stringliteral">" moved to "</span> &lt;&lt; mesh.point( v_it ) &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

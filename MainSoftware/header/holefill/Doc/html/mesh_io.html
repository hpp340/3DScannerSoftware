<html>
    <head>
      <title>OpenMesh: Mesh Input and Output</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="mesh_io">Mesh Input and Output</a></h1>This section explains the methods used to read a mesh from a file or write it to a file.<p>
The corresponding functions are defined in the namespace OpenMesh::MeshIO. This section is divided into three steps. Step one will give a short example on how to use the OpenMesh IOManager, step two will give some background information on how IOManager works and finally step three will show you how to add your own modules to IOManager.<h2><a class="anchor" name="mesh_io_quick">
Step 1 - IOManager quick start</a></h2>
For a quick start you can copy the following code directly to your project.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>

MyMesh mesh;

<span class="keywordflow">if</span> (!<a class="code" href="namespaceOpenMesh_1_1IO.html#d5533287a322aab83c19ea93ed626ae1">OpenMesh::IO::read_mesh</a>(mesh, <span class="stringliteral">"some input file"</span>)) 
{
  std::cerr &lt;&lt; <span class="stringliteral">"read error\n"</span>;
  exit(1);
}

<span class="comment">// do something with your mesh ...</span>

<span class="keywordflow">if</span> (!<a class="code" href="namespaceOpenMesh_1_1IO.html#696d75fb5550b5d1dadfd0aebe1468ec">OpenMesh::IO::write_mesh</a>(mesh, <span class="stringliteral">"some output file"</span>)) 
{
  std::cerr &lt;&lt; <span class="stringliteral">"write error\n"</span>;
  exit(1);
}
</pre></div><p>
<br>
<br>
<h2><a class="anchor" name="mesh_io_theory">
Step 2 - The theory behind IOManager</a></h2>
Usually mesh reader and writer routines are written directly against the data structure and the respective file format they support. This approach has the main disadvantage that targeting a different data structure or adding another file format leads to duplication of code.<p>
IOManager acts as an interface between persistent data on one side and an arbitrary data structure on the other side by means of reader/writer and importer/exporter modules. This is illustrated by the following diagramm :<p>
<div align="center">
<img src="iomanager.gif" alt="iomanager.gif">
</div>
<p>
<br>
<p>
Persistent data of arbitrary format is first interpreted by a reader module. The data is then passed - by means of a specified interface - to an importer module for the target data structure. The process for writing data is analogous. The IOManager controls the entire process. Reader/Writer modules are invisible to the user. Importer/Exporter however have to be specified explicitely as they are specific to a data structure.<p>
The complete separation of data structure and persistent data makes it especially easy to maintain existing code and to extend funtionality at both ends as will be shown in step three.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOpenMesh_1_1IO_1_1__IOManager__.html">OpenMesh::IO::_IOManager_</a></dd></dl>
<br>
<br>
<h2><a class="anchor" name="mesh_io_extend">
Step 3 - How to extend IOManager</a></h2>
<h3><a class="anchor" name="mesh_io_extend_fileformat">
Adding support for a new file format</a></h3>
Adding support for a new file format involves adding a reader and writer module. Reader modules are classes derived from <a class="el" href="classOpenMesh_1_1IO_1_1BaseReader.html">OpenMesh::IO::BaseReader</a>. The part of the interface that you usually have to define is shown below.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>BaseReader
{
<span class="keyword">public</span>:

  <span class="keyword">virtual</span> std::string get_description() <span class="keyword">const </span>= 0;
  <span class="keyword">virtual</span> std::string get_extensions() <span class="keyword">const </span>= 0;
  <span class="keyword">virtual</span> std::string get_magic()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::string(<span class="stringliteral">""</span>); }

  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> read(std::istream&amp; _is, BaseImporter&amp; _bi) <span class="keyword">const </span>= 0;
  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> read(<span class="keyword">const</span> std::string&amp; _filename, BaseImporter&amp; _bi) <span class="keyword">const </span>= 0;

  ...
};
</pre></div><p>
Based on the file extension or the header information the IOManager decides which reader module to use. The reader then parses the format and the information will be passed to the target data structure be means of a class derived from <a class="el" href="classOpenMesh_1_1IO_1_1BaseImporter.html">OpenMesh::IO::BaseImporter</a>.<p>
Writer modules are derived from <a class="el" href="classOpenMesh_1_1IO_1_1BaseWriter.html">OpenMesh::IO::BaseWriter</a> and work the same way as reader modules.<p>
<br>
<h3><a class="anchor" name="mesh_io_extend_datastruct">
Adding support for a new data structure</a></h3>
As we have already seen, Importers receive information from the reader modules. Reader modules pass information through a specified interface :<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>BaseImporter
{
<span class="keyword">public</span>:

  <span class="keyword">virtual</span> <span class="keywordtype">void</span> add_vertex  (<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3f</a>&amp;) {};
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> add_normal  (<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3f</a>&amp;) {};
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> add_texture (<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec2f</a>&amp;) {};
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> add_face    (<span class="keyword">const</span> FaceType&amp;)        {};
};
</pre></div><p>
The Importer is then responsible for filling the target data structure. Exporting information from a data structure is a little bit more involved than importing data to it. The writer modules must be able to iterate over all vectors/texcoords/faces. Therefore an exporter has to provide these iterators :<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>BaseExporter
{
<span class="keyword">public</span>:

  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update() = 0;
  
  <span class="keyword">virtual</span> PVertexIter const_vertices_begin()   = 0;
  <span class="keyword">virtual</span> PVertexIter const_vertices_end()     = 0;
  
  <span class="keyword">virtual</span> PTexCoordIter const_texcoords_begin() = 0;
  <span class="keyword">virtual</span> PTexCoordIter const_texcoords_end()   = 0;

  <span class="keyword">virtual</span> PIdxFaceIter const_idx_faces_begin() = 0;
  <span class="keyword">virtual</span> PIdxFaceIter const_idx_faces_end()   = 0;

  <span class="keyword">virtual</span> PFaceIter const_set_faces_begin() = 0;
  <span class="keyword">virtual</span> PFaceIter const_set_faces_end()   = 0;

  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_faces()     = 0;
  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vertices()  = 0;
  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_texcoords() = 0;
};
</pre></div><p>
There might be the need for the exporter to cache data from the structure it refers to. The update() function should be called at the beginning of each BaseWriter::save() method and it should make sure that cached information is up to date.<p>
For further information you are encouraged to take a look at the modules provided by OpenMesh which can be found in the IO subdirectory. <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

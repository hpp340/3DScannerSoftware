<html>
    <head>
      <title>OpenMesh: Using IO::Options</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial_08">Using IO::Options</a></h1>This example shows:<p>
<ul>
<li>How to control the behaviour of <code>Mesh::IO::read_mesh()</code>,</li><li>How to control the behaviour of <code>Mesh::IO::write_mesh()</code>.</li></ul>
<p>
The class <code><a class="el" href="classOpenMesh_1_1IO_1_1Options.html">OpenMesh::IO::Options</a></code> can be used when reading/writing a mesh. It controls the behaviour of the reader/writer modules by means of enabled/disabled bits in a bitset. The class provides an interface for enabling, disabling and verifying the bits in the set. We distinguish between<p>
<ol type=1>
<li>mode bits - control binary reading/writing<ul>
<li>Options::Binary</li><li>Options::MSB</li><li>Options::LSB</li><li>Options::Swap (MSB|LSB)</li></ul>
</li><li>property bits - controls which standard properties to read/write<ul>
<li>Options::VertexNormal</li><li>Options::VertexTexCoord</li><li>Options::VertexColor</li><li>Options::FaceNormal</li><li>Options::FaceColor</li></ul>
</li></ol>
<p>
These bits have different effects when reading or writing. The file format itself is selected by the extension of the filename. The IO subsystem of the OpenMesh library supports currently four formats. The following table list all formats and indicates whether the format supports ASCII/binary storage with the apropiate extension.<p>
<table border="0>" cellspacing="3" cellpadding="3">
<tr>
<td>Format</td><td colspan="2>">Ascii</td><td>Binary </td></tr>
<tr>
<td>OFF</td><td>.off</td><td>.off </td></tr>
<tr>
<td>OBJ</td><td>.obj</td><td></td></tr>
<tr>
<td>STL</td><td>.stla, .stl</td><td>.stlb, .stl </td></tr>
<tr>
<td>OM</td><td></td><td>.om  </td></tr>
</table>
<p>
The program does not more than providing a command line based interface to select the option bits for reading/writing and to request mesh properties. Hence illegal combinations are possible and will result in a failure of the program. (The input file won't be damaged in this case, but becareful where you put the ouput file!)<p>
<h5>Reading meshes</h5>
<p>
When reading a file the mode bits are used to give the reader an advice or hint. Depending on the format we can help the reader to interpret the data correctly. First of all we can tell it that the file contains binary data.<p>
 <div class="fragment"><pre class="fragment">        ropt += IO::Options::Binary; 
</pre></div><p>
Further on we can ask the reader two swap the byte-order.<p>
<div class="fragment"><pre class="fragment">        ropt += IO::Options::Swap; 
</pre></div><p>
(Both can be done via the command line with the options -b and -s, respectively.)<p>
By default the geometry and the topology is restored from the file. The file might contain more, especially it could provide normals or texture coordinates. We can examine the property bits after reading to find out what else is available:<p>
 <div class="fragment"><pre class="fragment">                ropt.check(IO::Options::VertexNormal) 
</pre></div><p>
If a property bit is set it does not mean, that it has been restored as well. The property must have been requested prior reading the file. (The demo program offers the command line option <code>-Xv</code>[nct] and <code>-Xf</code>[nc] to request vertex and face properties.)<p>
<h5>Writing meshes</h5>
<p>
When writing the mesh the mode bits apparently control whether to use the binary variant and the desired byte-ordering. For example, if we choose binary mode and want to swap the byte order, we set<p>
<div class="fragment"><pre class="fragment">        wopt += IO::Options::Binary; 
        wopt += IO::Options::Swap; 
</pre></div><p>
If the format does not specify the byte order the system byte order is used. If the format does not support binary storage, the mode bits are ignored.<p>
If the format supports storing additional information, which are conform with the standard properties, we can use the property bits to tell the writer what we would like to have stored. If we would like to store the vertex normals we simply set<p>
<div class="fragment"><pre class="fragment">              wopt += IO::Options::VertexNormal; 
</pre></div><p>
Finally we can write the data to the file<p>
 <div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> ( !IO::write_mesh( mesh, argv[optind+1], wopt ) )
</pre></div><p>
The method returns false on error, which might have three different reasons:<p>
<ol type=1>
<li>the option is not supported by the choosen format</li><li>a selected standard property is not available</li><li>a 'system' error like<ul>
<li>could not open the file due to access rights</li><li>disk space exhausted during write</li><li>...</li></ul>
</li></ol>
<p>
The complete source looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="comment">// -------------------- OpenMesh</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Tools/Utils/getopt.h&gt;</span>

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keyword">using namespace </span>OpenMesh;

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keyword">typedef</span> TriMesh_ArrayKernelT&lt;&gt;  MyMesh;

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="preprocessor">#define CHKROPT( Option ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; "  provides " &lt;&lt; #Option \</span>
<span class="preprocessor">            &lt;&lt; (ropt.check(IO::Options:: Option)?": yes\n":": no\n")</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define CHKWOPT( Option ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; "  write " &lt;&lt; #Option \</span>
<span class="preprocessor">            &lt;&lt; (wopt.check(IO::Options:: Option)?": yes\n":": no\n")</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define MESHOPT( msg, tf ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; "  " &lt;&lt; msg &lt;&lt; ": " &lt;&lt; ((tf)?"yes\n":"no\n")</span>
<span class="preprocessor"></span>
<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">void</span> parse_commandline( <span class="keywordtype">int</span> _argc, <span class="keywordtype">char</span> **_argv, MyMesh&amp; _mesh,
                        IO::Options &amp;ropt, IO::Options &amp;wopt );

<span class="keywordtype">void</span> usage_and_exit(<span class="keywordtype">int</span> xcode);

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;
  IO::Options ropt, wopt;

  <span class="comment">// -------------------- evaluate commandline</span>

  parse_commandline( argc, argv, mesh, ropt, wopt );

  <span class="comment">// -------------------- read mesh</span>

  <span class="keywordflow">if</span> ( ! IO::read_mesh(mesh,argv[optind], ropt))
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error loading mesh from file "</span> &lt;&lt; argv[optind] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// -------------------- show options</span>

  std::cout &lt;&lt; <span class="stringliteral">"File "</span> &lt;&lt; argv[optind] &lt;&lt; std::endl;

  std::cout &lt;&lt; <span class="stringliteral">"  is binary: "</span> 
            &lt;&lt; (ropt.check(IO::Options::Binary) ? <span class="stringliteral">" yes\n"</span> : <span class="stringliteral">" no\n"</span>);

  std::cout &lt;&lt; <span class="stringliteral">"  byte order: "</span>;
  <span class="keywordflow">if</span> (ropt.check(IO::Options::Swap))
    std::cout &lt;&lt; <span class="stringliteral">"swapped\n"</span>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ropt.check(IO::Options::LSB))
    std::cout &lt;&lt; <span class="stringliteral">"little endian\n"</span>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ropt.check(IO::Options::MSB))
    std::cout &lt;&lt; <span class="stringliteral">"big endian\n"</span>;
  <span class="keywordflow">else</span>
    std::cout &lt;&lt; <span class="stringliteral">"don't care\n"</span>;
  
  std::cout &lt;&lt; <span class="stringliteral">"  provides VertexNormal"</span>
            &lt;&lt; ( <span class="comment">// strange layout for doxygen</span>
                ropt.check(IO::Options::VertexNormal) 
                ? <span class="stringliteral">": yes\n"</span>:<span class="stringliteral">": no\n"</span>);
  CHKROPT( VertexColor    );
  CHKROPT( VertexTexCoord );
  CHKROPT( FaceNormal     );
  CHKROPT( FaceColor      );


  <span class="comment">// -------------------- mesh stats</span>

  std::cout &lt;&lt; <span class="stringliteral">"# Vertices: "</span> &lt;&lt; mesh.n_vertices() &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="stringliteral">"# Edges   : "</span> &lt;&lt; mesh.n_faces() &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="stringliteral">"# Faces   : "</span> &lt;&lt; mesh.n_faces() &lt;&lt; std::endl;


  <span class="comment">// -------------------- show write options</span>

  std::cout &lt;&lt; <span class="stringliteral">"Selected write options:\n"</span>;
  std::cout &lt;&lt; <span class="stringliteral">"  use binary: "</span> 
            &lt;&lt; (wopt.check(IO::Options::Binary) ? <span class="stringliteral">" yes\n"</span> : <span class="stringliteral">" no\n"</span>);

  std::cout &lt;&lt; <span class="stringliteral">"  byte order: "</span>;
  <span class="keywordflow">if</span> (wopt.check(IO::Options::Swap))
    std::cout &lt;&lt; <span class="stringliteral">"swapped\n"</span>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wopt.check(IO::Options::LSB))
    std::cout &lt;&lt; <span class="stringliteral">"little endian\n"</span>;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wopt.check(IO::Options::MSB))
    std::cout &lt;&lt; <span class="stringliteral">"big endian\n"</span>;
  <span class="keywordflow">else</span>
    std::cout &lt;&lt; <span class="stringliteral">"don't care\n"</span>;
  
  std::cout &lt;&lt; <span class="stringliteral">"  write VertexNormal"</span>
            &lt;&lt; (wopt.check(IO::Options::VertexNormal) ? <span class="stringliteral">": yes\n"</span>:<span class="stringliteral">": no\n"</span>);
  CHKWOPT( VertexColor    );
  CHKWOPT( VertexTexCoord );
  CHKWOPT( FaceNormal     );
  CHKWOPT( FaceColor      );

  <span class="comment">// -------------------- show mesh capabilities</span>

  std::cout &lt;&lt; <span class="stringliteral">"Mesh supports\n"</span>;
  MESHOPT(<span class="stringliteral">"vertex normals"</span>, mesh.has_vertex_normals());
  MESHOPT(<span class="stringliteral">"vertex colors"</span>, mesh.has_vertex_colors());
  MESHOPT(<span class="stringliteral">"texcoords"</span>, mesh.has_vertex_texcoords2D());
  MESHOPT(<span class="stringliteral">"face normals"</span>, mesh.has_face_normals());
  MESHOPT(<span class="stringliteral">"face colors"</span>, mesh.has_face_colors());

  <span class="comment">// -------------------- write mesh</span>

  std::cout &lt;&lt; <span class="stringliteral">"Write mesh to "</span> &lt;&lt; argv[optind+1] &lt;&lt; <span class="stringliteral">".."</span>;
  <span class="keywordflow">if</span> ( !IO::write_mesh( mesh, argv[optind+1], wopt ) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error"</span> &lt;&lt; std::endl;
    std::cerr &lt;&lt; <span class="stringliteral">"Possible reasons:\n"</span>;
    std::cerr &lt;&lt; <span class="stringliteral">"1. Chosen format cannot handle an option!\n"</span>;
    std::cerr &lt;&lt; <span class="stringliteral">"2. Mesh does not provide necessary information!\n"</span>;
    std::cerr &lt;&lt; <span class="stringliteral">"3. Or simply cannot open file for writing!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }
  <span class="keywordflow">else</span>
    std::cout &lt;&lt; <span class="stringliteral">"Ok.\n"</span>;

  <span class="keywordflow">return</span> 0;
}

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">void</span> parse_commandline( <span class="keywordtype">int</span> _argc, <span class="keywordtype">char</span> **_argv, MyMesh&amp; _mesh,
                        IO::Options &amp;ropt, IO::Options &amp;wopt )
{
  <span class="keywordtype">int</span> c;
  <span class="keywordflow">while</span> ((c=getopt(_argc, _argv, <span class="stringliteral">"bhsBF:LMSV:X:"</span>))!=-1)
  {
    <span class="keywordflow">switch</span>(c) 
    {
      <span class="comment">// -------------------- read options</span>

      <span class="comment">// force binary input</span>
      <span class="keywordflow">case</span> <span class="charliteral">'b'</span>: 
        ropt += IO::Options::Binary; 
        <span class="keywordflow">break</span>;

      <span class="comment">// force swapping the byte order, when reading a binary file</span>
      <span class="keywordflow">case</span> <span class="charliteral">'s'</span>: 
        ropt += IO::Options::Swap; 
        <span class="keywordflow">break</span>;

      <span class="comment">// -------------------- write options</span>

      <span class="comment">// Write binary variant of format if possible</span>
      <span class="keywordflow">case</span> <span class="charliteral">'B'</span>: 
        wopt += IO::Options::Binary; 
        <span class="keywordflow">break</span>;

      <span class="comment">// </span>
      <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
        <span class="keywordflow">for</span>(size_t i=0; optarg[i]; ++i)
          <span class="keywordflow">switch</span>(optarg[i]) {
            <span class="keywordflow">case</span> <span class="charliteral">'n'</span> : wopt += IO::Options::FaceNormal; <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'c'</span> : wopt += IO::Options::FaceColor; <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">break</span>;

      <span class="comment">// Use little endian when writing binary data</span>
      <span class="keywordflow">case</span> <span class="charliteral">'L'</span>: 
        wopt += IO::Options::LSB; 
        <span class="keywordflow">break</span>;

      <span class="comment">// Use big endian when writing binary data</span>
      <span class="keywordflow">case</span> <span class="charliteral">'M'</span>: 
        wopt += IO::Options::MSB; 
        <span class="keywordflow">break</span>;

      <span class="comment">// Swap byte order when writing binary data</span>
      <span class="keywordflow">case</span> <span class="charliteral">'S'</span>: 
        wopt += IO::Options::Swap; 
        <span class="keywordflow">break</span>;

      <span class="comment">//</span>
      <span class="keywordflow">case</span> <span class="charliteral">'V'</span>:
      {
        <span class="keywordflow">for</span>(size_t i=0; optarg[i]; ++i)
          <span class="keywordflow">switch</span>(optarg[i]) {
            <span class="keywordflow">case</span> <span class="charliteral">'n'</span> : <span class="comment">// dont't change layout!!</span>
              wopt += IO::Options::VertexNormal; 
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'t'</span> : wopt += IO::Options::VertexTexCoord; <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'c'</span> : wopt += IO::Options::VertexColor; <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">break</span>;
      }

      <span class="comment">// -------------------- request mesh' standard properties</span>
      <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
      {        
        <span class="keywordtype">char</span> entity=<span class="charliteral">'\0'</span>;
        <span class="keywordflow">for</span>(size_t i=0; optarg[i]; ++i)
          <span class="keywordflow">switch</span>(optarg[i]) {
            <span class="keywordflow">case</span> <span class="charliteral">'v'</span>: 
            <span class="keywordflow">case</span> <span class="charliteral">'f'</span>: entity = optarg[i]; <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
              <span class="keywordflow">switch</span>(entity) {
                <span class="keywordflow">case</span> <span class="charliteral">'v'</span>: _mesh.request_vertex_normals(); <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <span class="charliteral">'f'</span>: _mesh.request_face_normals(); <span class="keywordflow">break</span>;
              }
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
              <span class="keywordflow">switch</span>(entity) {
                <span class="keywordflow">case</span> <span class="charliteral">'v'</span>: _mesh.request_vertex_colors(); <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <span class="charliteral">'f'</span>: _mesh.request_face_colors(); <span class="keywordflow">break</span>;
              }
              <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
              <span class="keywordflow">switch</span>(entity) {
                <span class="keywordflow">case</span> <span class="charliteral">'v'</span>: _mesh.request_vertex_texcoords2D(); <span class="keywordflow">break</span>;
              }
              <span class="keywordflow">break</span>;
          }
        <span class="keywordflow">break</span>;
      }
      
      <span class="comment">// -------------------- help</span>
      <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
        usage_and_exit(0);
      <span class="keywordflow">default</span>:
        usage_and_exit(1);
    }
  }

  <span class="keywordflow">if</span> ( _argc-optind != 2)
    usage_and_exit(1);
}


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">void</span> usage_and_exit(<span class="keywordtype">int</span> xcode)
{
  std::ostream &amp;os = xcode ? std::cerr : std::cout;

  os &lt;&lt; <span class="stringliteral">"Usage: io_options [Options] &lt;input&gt; &lt;output&gt;\n"</span> 
     &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">"  Read and write a mesh, using OpenMesh::IO::Options\n"</span>
     &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">"Options:\n"</span>
     &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">"a) read options\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -b\n"</span>
     &lt;&lt; <span class="stringliteral">"\tAssume input file is a binary file\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -s\n"</span>
     &lt;&lt; <span class="stringliteral">"\tSwap byte order when reading a binary file!\n"</span>
     &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">"b) write options\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -B\n"</span>
     &lt;&lt; <span class="stringliteral">"\tWrite binary data\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -S\n"</span>
     &lt;&lt; <span class="stringliteral">"\tSwap byte order, when writing binary data\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -M/-L\n"</span>
     &lt;&lt; <span class="stringliteral">"\tUse MSB/LSB byte ordering, when writing binary data\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -V{n|t|c}\n"</span>
     &lt;&lt; <span class="stringliteral">"\tWrite vertex normals, texcoords, and/or colors\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -F{n|c}\n"</span>
     &lt;&lt; <span class="stringliteral">"\tWrite face normals, and/or colors\n"</span>
     &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">"c) Mesh properties\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -Xv{n|c|t}\n"</span>
     &lt;&lt; <span class="stringliteral">"\tRequest vertex property normals|colors|texcoords\n"</span>
     &lt;&lt; std::endl
     &lt;&lt; <span class="stringliteral">"  -Xf{n|c}\n"</span>
     &lt;&lt; <span class="stringliteral">"\tRequest face property normals|colors\n"</span>
     &lt;&lt; std::endl;
  exit(xcode);
}

<span class="comment">// end of file</span>
<span class="comment">// ============================================================================</span>
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

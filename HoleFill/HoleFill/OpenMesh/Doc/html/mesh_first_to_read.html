<html>
    <head>
      <title>OpenMesh: Read me first!!!</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="mesh_first_to_read">Read me first!!!</a></h1>Please note, that OpenMesh makes heavily use of C++ templates, generic programming and all that stuff (see <a class="el" href="mesh_cpp.html">Some words on the C++ implementation</a>).<p>
Therefore read this section carefully (else you get lost in the reference manual):<p>
<h3>There is no such thing like the OpenMesh class</h3>
<p>
The library provides a set of classes ( 99% templates ;-) ), where the inheritance relationship is given by template parameterization. You might ask: "What the heck is that?" It means, a parent class is passed as a template argument to another class:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>P1 { }
<span class="keyword">class </span>P2 { }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Parent&gt; <span class="keyword">class </span>B : <span class="keyword">public</span> Parent {}

<span class="keyword">typedef</span> B&lt;P1&gt; fooB1;
<span class="keyword">typedef</span> B&lt;P2&gt; fooB2;
</pre></div><p>
Voila, we have created two different types of B. Depending on the interface, the public member elements, provided by <code>P1</code> or <code>P2</code>, <code>fooB1</code> and <code>fooB2</code> might have different behaviours or even different interfaces! But if <code>P1</code> and <code>P2</code> have the some interface or at least a common interface, then from programming point of view there is no difference using <code>fooB1</code> or <code>fooB2</code>. And this is all about. OpenMesh defines an interface concept for the kernel which is documented in <a class="el" href="classOpenMesh_1_1Concepts_1_1KernelT.html">OpenMesh::Concepts::KernelT</a>. As long as the kernel provides this the class handling polygonal meshes <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html">OpenMesh::PolyMeshT</a></code> can use any kernel.<p>
<h3>Therefore documentation resides in two spaces</h3>
<p>
<ol type=1>
<li>Associated with the class/struct (as usual)</li><li>In a concept class in cases like the example code above. Hence, if you want to know what a mesh type has to offer refer to <a class="el" href="classOpenMesh_1_1Concepts_1_1KernelT.html">OpenMesh::Concepts::KernelT</a>, <a class="el" href="classOpenMesh_1_1PolyMeshT.html">OpenMesh::PolyMeshT</a>, <a class="el" href="classOpenMesh_1_1TriMeshT.html">OpenMesh::TriMeshT</a>. </li></ol>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

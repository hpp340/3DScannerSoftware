<html>
    <head>
      <title>OpenMesh: Specifying your MyMesh</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="mesh_type">Specifying your MyMesh</a></h1>This section will show how to build your own custom tailored type <code>MyMesh</code>.<p>
As we have seen in the section on goals and features there are some parameters to be specified for a mesh. This is done in the following four steps:<p>
<ol>
<li>
Choose between triangle mesh and general polygonal mesh.<p>
</li>
<li>
Select the mesh kernel<p>
</li>
<li>
Parameterize the mesh by a so-called <em>Traits</em> class. You can add arbitrary classes to the mesh items, specify the types <code>Scalar</code>, <code>Point</code>, <code>Normal</code> and <code>Color</code>, and use predefined attributes like <code>Attributes::Normal</code> and <code>Attributes::Color</code>.<p>
</li>
<li>
Dynamically bind data to the mesh or the mesh entities (vertex, (half-)edge, face) using <em>custom</em> <em>properties</em>.<p>
</li>
</ol>
<p>
We will explain these four parameterization steps and give a code example at the end of this page.<p>
<br>
<br>
<h2><a class="anchor" name="sec_select_face_type">
Polygonal or Triangle Mesh?</a></h2>
This decision is quite simple: Whenever possible choose the triangle mesh. The restriction to triangular faces usually leads to more efficient algorithms (e.g. rendering triangles is much faster than rendering arbitrary polygons). Additionally some algorithms are only implemented for triangle meshes while triangle meshes inherit the full functionality of polygonal meshes. For a list of them refer to the following links.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOpenMesh_1_1PolyMeshT.html">OpenMesh::PolyMeshT</a> <p>
<a class="el" href="classOpenMesh_1_1TriMeshT.html">OpenMesh::TriMeshT</a></dd></dl>
<br>
<br>
<h2><a class="anchor" name="sec_select_kernel">
Choosing the right kernel</a></h2>
The mesh kernel specifies how the mesh entities (vertices, (half-)edges, faces) are internally stored. In fact the entities are kept in so-called properties. A property itself provides an array like interface. The kernel defines the corresponding handle types, i.e. the way items reference each other. Since the properties have an array like interface the handles are represented internally as indices.<p>
The default kernel is <code>ArrayKernelT</code>. Which is good for most situations. But depending on the application a different kernel would be better. E.g. the OpenSG integration has been realized be replacing the kernel by a custom kernel, since OpenSG provides already array like properties, which could be reused for the intergration. In case of a an OpenSG environment one might be better off using <code>OSG_Kernel::ArrayKernelT</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__mesh__kernels__group.html">Mesh Kernels</a></dd></dl>
<br>
<br>
<h2><a class="anchor" name="sec_select_traits">
Mesh Traits</a></h2>
While the last two sections only have chosen from a list of predefined meshes or kernels, respectively, we now come to the user-defined customization.<p>
The resulting mesh <code>MyMesh</code> will provide the following types:<p>
<ul>
<li>
The <em>point</em> and <em>scalar</em> type: <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a></code> and <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#f9e609f25989239b717eecdc385c9f7d">MyMesh::Scalar</a></code>. </li>
<li>
The <em>mesh items</em>: <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#675d913d85c18cb2635b8fbaea362c56">MyMesh::Vertex</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#5a8c25dc1d40e8ead63ff637a476443b">MyMesh::Halfedge</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#d8f6697ffefe85935b4fd41962e13d92">MyMesh::Edge</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#6531cf89f56fbee6194162e6402bbc67">MyMesh::Face</a></code>. </li>
<li>
The <em>handle</em> types: <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#46bd6f0df4c9e2821bbcb006596f37ef">MyMesh::VertexHandle</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#f98c68d0ab1fef6faeadafaccc071129">MyMesh::HalfedgeHandle</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#ed723ae8595ba1d051e1f9ccac8f2657">MyMesh::EdgeHandle</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#6456ee0daf9ba9eea34b0f10a1e92975">MyMesh::FaceHandle</a></code>. </li>
</ul>
<p>
While the handle types are fixed, the other types can be customized. Each mesh type (see <a class="el" href="group__mesh__types__group.html">Predefined Mesh Types</a>) can be parameterized by a so-called <em>traits</em> class. Using this mechanism one can<p>
<ol>
<li>
change the coordinate type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a></code> and the resulting scalar type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#f9e609f25989239b717eecdc385c9f7d">MyMesh::Scalar</a></code> == <code>MyMesh::Point::value_type</code>, </li>
<li>
change the normal type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#2d5544e9953addba9971e264ecf6d729">MyMesh::Normal</a></code> </li>
<li>
change the color type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#bd3f83a0fd6421c512ccc2c5b0e1cc5f">MyMesh::Color</a></code> </li>
<li>
use predefined attributes like normal vector, color, texture coordinates, ... for the mesh items. </li>
<li>
add arbitrary classes the mesh items. </li>
</ol>
<p>
All these customizations are encapsulated in one class <code>MyTraits</code>, that is used as template argument to the mesh, e.g. <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits { 
  <span class="comment">// your customization </span>
};
<span class="keyword">typedef</span> PolyMesh_ArrayKernelT&lt;MyTraits&gt;  <a class="code" href="classOpenMesh_1_1PolyMesh__ArrayKernelT.html">MyMesh</a>;
</pre></div><p>
The rest of this section explains the construction of this traits class, its application to the mesh will be the topic of the next section.<p>
For each mesh entity one can control the predefined attributes to be attached by a traits class using some convenience macros, e.g. <code><a class="el" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">OpenMesh::VertexAttributes</a></code> and <code><a class="el" href="Core_2Mesh_2Traits_8hh.html#11769422db3a92609470ff09ea643d87">OpenMesh::VertexTraits</a></code> for vertices. The default traits class looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>DefaultTraits
{
  <span class="keyword">typedef</span> <a class="code" href="namespaceOpenMesh.html#3470a8299d88328d7019b93aef9852c2">Vec3f</a>  Point;
  <span class="keyword">typedef</span> <a class="code" href="namespaceOpenMesh.html#3470a8299d88328d7019b93aef9852c2">Vec3f</a>  <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">Normal</a>;
  <span class="keyword">typedef</span> <a class="code" href="namespaceOpenMesh.html#5a784d470e5390aff22389688aa939f0">Vec2f</a>  TexCoord;
  <span class="keyword">typedef</span> <a class="code" href="namespaceOpenMesh.html#ee22d3e59abc4b95dbf7f5c6b4a1be66">Vec3uc</a> <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc362d138c17efa0c78fef62c418953f67b8">Color</a>;

  <a class="code" href="Core_2Mesh_2Traits_8hh.html#11769422db3a92609470ff09ea643d87">VertexTraits</a>    {};
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#a52d69929bb2a7c514eb9f7ec55b31bb">HalfedgeTraits</a>  {};
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#c107ec6027998447d0cf8ff46ab60787">EdgeTraits</a>      {};
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#1b828a168d1a32a6a5ecaca2707176be">FaceTraits</a>      {};
  
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">VertexAttributes</a>(0);
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#2f7526fd98f8939feedb0edc9f430794">HalfedgeAttributes</a>(<a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc3698cca64c8972265b612cb15552bc82ed">Attributes::PrevHalfedge</a>);
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#913a810930e97ba5f27c6d51fc1ae5e8">EdgeAttributes</a>(0);
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#d1f28c7308ba404416cbb8f0bf337181">FaceAttributes</a>(0);
};
</pre></div><p>
Please note that for example <code>VertexTraits</code> is a define concealing a template declaration. The actual template class name is <code>VertexT</code>, which is further simplified to a specific type <code>Vertex</code> at a later stage during the construction of the mesh kernel.<p>
Because the traits classes always have to provide the template classes <code>VertexT</code>, <code>HalfedgeT</code>, <code>EdgeT</code>, <code>FaceT</code>, and the types <code>Point</code>, <code>Normal</code>, <code>Color</code>, and <code>TexCoord</code> one should derive this class from the default implementation <code>DefaultTraits</code>. In this case you will only have to define the classes or types you want to override or substitute.<p>
<br>
 <h3><a class="anchor" name="sec_change_point">
Changing the Point type</a></h3>
Changing the type that is used to store the point coordinates as well as the normal vectors can simply be done by defining this type in the traits class. The following code changes the coordinate type in order to use <code>double</code> instead of <code>float</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> Point; <span class="comment">// use double-values points</span>
};
</pre></div><p>
Using the <a class="el" href="classOpenMesh_1_1VectorT.html">OpenMesh::VectorT</a> class you can easily plug in any scalar type for the use in point coordinates, e.g. some exact arithmetic. You can also exchange the whole class representing points as long as it provides the same interface as the <a class="el" href="classOpenMesh_1_1VectorT.html">OpenMesh::VectorT</a> class.<p>
<br>
 <h3><a class="anchor" name="sec_add_attributes">
Adding Predefined Attributes</a></h3>
There are some pre-defined attributes that can be appended to the mesh items. These global attributes are defined in the namespace <a class="el" href="namespaceOpenMesh_1_1Attributes.html">OpenMesh::Attributes</a>. The advantage of these attributes is that they are registered at the items they are added to. Therefore algorithms can check for these attributes at run-time as well as at compile-time. This is important if you want to implement algorithms acting on different meshes, that may or may not have e.g. normal vectors per vertex/face.<p>
Adding these predefined attributes is quite simple. You provide an <code>unsigned int</code> in the traits class, whose bits control whether or not a certain attribute should be attached or not.<p>
If you want to add a normal vector to your vertices and faces, and also want to have color information for vertices, the code would look like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits 
{
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">VertexAttributes</a>( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> |
                    <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc362d138c17efa0c78fef62c418953f67b8">OpenMesh::Attributes::Color</a> );

  <a class="code" href="Core_2Mesh_2Traits_8hh.html#d1f28c7308ba404416cbb8f0bf337181">FaceAttributes</a>( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::Attributes::Normal</a> );
};
</pre></div><p>
Internally each mesh item contains an <code>enum</code> defining the integer <code>Attributes</code> (containing the bits of used attributes OR'ed together). From its set/unset bits you can see whether a certain attribute is used. <a class="el" href="namespaceOpenMesh.html">OpenMesh</a> provides the macro OM_Check_Attrib for doing this:<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (OM_Check_Attrib(<a class="code" href="classOpenMesh_1_1PolyMeshT.html#675d913d85c18cb2635b8fbaea362c56">MyMesh::Vertex</a>, <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">Normal</a>) 
  do_something_with_normals();
</pre></div><p>
These run-time checks may not be sufficient in some cases. You can also check for attributes at compile-time and instantiate the correct functions by using function overloading. The class <code>GenProg::Bool2Type</code> maps true/false information to two different types, <code>Bool2Type&lt;true&gt;</code> and <code>Bool2Type&lt;false&gt;</code>. An example that draws OpenGL normals if they are available would look like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;OpenMesh/Core/Utils/GenProg.hh&gt;</span>

<span class="comment">// draw a face normal if we have one</span>
<span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1PolyMeshT.html#6531cf89f56fbee6194162e6402bbc67">MyMesh::Face</a>&amp; _f) { 
  drawFaceNormal(_f, GenProg::Bool2Type&lt;OM_Check_Attrib(<a class="code" href="classOpenMesh_1_1PolyMeshT.html#6531cf89f56fbee6194162e6402bbc67">MyMesh::Face</a>, <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">Normal</a>)&gt;()); 
}

<span class="comment">// normal exists -&gt; use it</span>
<span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1PolyMeshT.html#6531cf89f56fbee6194162e6402bbc67">MyMesh::Face</a>&amp; _f, GenProg::Bool2Type&lt;true&gt;) { 
  glNormal3fv(_f.normal());
}

<span class="comment">// empty dummy (no normals)</span>
<span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="classOpenMesh_1_1PolyMeshT.html#6531cf89f56fbee6194162e6402bbc67">MyMesh::Face</a>&amp; _f, GenProg::Bool2Type&lt;false&gt;){}
</pre></div><p>
Especially the compile-time checking for attributes is extremely useful because it does not generate any unnecessary code and does not perform expensive tests at run-time.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structOpenMesh_1_1DefaultTraits.html">OpenMesh::DefaultTraits</a> <p>
<a class="el" href="namespaceOpenMesh_1_1Attributes.html">OpenMesh::Attributes</a> <p>
<a class="el" href="namespaceOpenMesh_1_1GenProg.html">OpenMesh::GenProg</a></dd></dl>
<br>
 <h3><a class="anchor" name="sec_add_traits">
Adding User-Defined Elements</a></h3>
You can also add arbitrary types/elements/methods to the mesh items by providing a corresponding traits class for these items. Adding some index to the <code>Vertex</code> class is easily done by<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#11769422db3a92609470ff09ea643d87">VertexTraits</a>
  {
    <span class="keywordtype">int</span> some_additional_index;
  };
};
</pre></div><p>
The macro <code>VertexTraits</code> hides some ugly template stuff. In fact, it is defined as<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define VertexTraits template &lt;class Base, class Refs&gt; struct VertexT : public Base</span>
</pre></div><p>
hence the traits class actually looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base, <span class="keyword">class</span> Refs&gt; <span class="keyword">struct </span>VertexT : <span class="keyword">public</span> Base
  {
    <span class="keywordtype">int</span> some_additional_index;
  };
};
</pre></div><p>
You have to keep this in mind when you want to define constructors for your vertex type or when you want to derive the vertex type from other classes.<p>
The template argument <code>Base</code> provides access to the mesh handles and to the <code>Point</code> and <code>Scalar</code> type by its member class <code>Refs</code>. Adding a <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#6456ee0daf9ba9eea34b0f10a1e92975">MyMesh::FaceHandle</a></code> to the vertex class can therefore be implemented like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits 
{
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#11769422db3a92609470ff09ea643d87">VertexTraits</a>
  {
    <span class="keywordtype">int</span> some_additional_index;
    <span class="keyword">typename</span> Base::Refs::FaceHandle my_face_handle;
  };
};
</pre></div><p>
Adding elements to other mesh items works in the same manner.<p>
<br>
 <h3><a class="anchor" name="sec_algo_traits">
Using traits defined by algorithms</a></h3>
From version 0.10.3 on algorithms can define traits/attributes they require and the user can merge these traits into his own traits. A more elegant way is to use dynamic properites, which can be added/removed during runtime by the algorithm. This is the preferred way to attach custom data to the mesh.<p>
An example for an algorithm as well as the application using traits is given in <a class="el" href="tutorial_06.html">Using mesh traits and attributes</a>.<p>
<br>
<br>
<h2><a class="anchor" name="sec_properties">
Dynamic Properties</a></h2>
From version 1.0 on OpenMesh provides dynamic properties. Instead of using traits to bind data at compile time algorithms or the application can use dynamic properties. Similar to entities the properties are accessed and manipulated via handles.<p>
An example for an algorithm as well as the application using properties is given in <a class="el" href="tutorial_03.html">Using (custom) properites</a> and <a class="el" href="tutorial_04.html">Using STL algorithms</a>.<p>
<br>
<br>
<h2><a class="anchor" name="sec_traits_example">
Final Implementation Example</a></h2>
Consider an application where we just want to render triangle meshes. This means we will select the triangle mesh and the <code>ArrayKernelT</code>. Faces that are not triangles will automatically be tesselated into triangles. Because we only display meshes and do not dynamically add or remove items, we can just use the <code>ArrayKernelT</code>.<p>
All mesh-kernel combinations are predefined in the directory <code>OpenMesh/Mesh/Types</code>. Refer to <a class="el" href="group__mesh__types__group.html">Predefined Mesh Types</a> for a complete list of them. For our example we use the <code>TriMesh_ArrayKernelT</code> and parameterize it by our <code>MyTraits</code> class.<p>
We will need face and vertex normals and e.g. for color coding vertex curvature, i.e. vertex color.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>


<span class="comment">// define traits</span>
<span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <span class="comment">// use double valued coordinates</span>
  <span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1VectorT.html">OpenMesh::Vec3d</a> Point;

  <span class="comment">// use vertex normals and vertex colors</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#f62a65b46b44579c3a1f62558ff911fd">VertexAttributes</a>( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::DefaultAttributer::Normal</a> |
                    <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc362d138c17efa0c78fef62c418953f67b8">OpenMesh::DefaultAttributer::Color</a> );

  <span class="comment">// store the previous halfedge</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#2f7526fd98f8939feedb0edc9f430794">HalfedgeAttributes</a>( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc3698cca64c8972265b612cb15552bc82ed">OpenMesh::DefaultAttributer::PrevHalfedge</a> );

  <span class="comment">// use face normals</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#d1f28c7308ba404416cbb8f0bf337181">FaceAttributes</a>( <a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc36db7eb24f77619b9be9fa2659f0a79ef0">OpenMesh::DefaultAttributer::Normal</a> );

  <span class="comment">// store a face handle for each vertex</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#11769422db3a92609470ff09ea643d87">VertexTraits</a>
  {
    <span class="keyword">typename</span> Base::Refs::FaceHandle my_face_handle;
  };

};


<span class="comment">// Select mesh type (TriMesh) and kernel (ArrayKernel)</span>
<span class="comment">// and define my personal mesh type (MyMesh)</span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh mesh;

  <span class="comment">// -------------------- Add dynamic data</span>

  <span class="comment">// for each vertex an extra double value</span>
  <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt; double &gt;</a> vprop_double;
  mesh.add_property( vprop_double );

  <span class="comment">// for the mesh an extra string</span>
  <a class="code" href="structOpenMesh_1_1MPropHandleT.html">OpenMesh::MPropHandleT&lt; string &gt;</a> mprop_string;
  mesh.add_property( mprop_string );

  <span class="comment">// -------------------- do something</span>

  ...;

}
</pre></div><p>
That's it. <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

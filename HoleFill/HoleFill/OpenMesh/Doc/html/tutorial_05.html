<html>
    <head>
      <title>OpenMesh: Using standard properties</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial_05">Using standard properties</a></h1>This examples shows:<p>
<ul>
<li>How to add and remove a standard property,</li><li>How to get and set the value of a standard property.</li></ul>
<p>
As we already have seen, we can bind additional data to the mesh entities by means of properties. OpenMesh provides a set of so-called standard properties. Unlike the custom properties these have some special features and a different interface, which are the matter this tutorial.<p>
The following table lists all available standard properties and the suitable entity for which it can be used.<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>&nbsp; </td><td>Vertex </td><td>Face </td><td>Edge </td><td>Halfedge  </td></tr>
<tr>
<td>Color </td><td>X </td><td>X </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Normal </td><td>X </td><td>X </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Position <sup> (*) </sup>  </td><td>X </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
<tr>
<td>Status </td><td>X </td><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<td>TexCoord </td><td>X </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp;  </td></tr>
</table>
<p>
To add a standard property to an entity simply use the appropriate request method, e.g. <code> request_face_normal</code>(). The only exception is the position <sup>(*)</sup>. It cannot be added because it is permanently available, hence it cannot be remove as well.<p>
In this example we<ol type=1>
<li>add vertex normals to a mesh object</li><li>load a file</li><li>check if the file provides vertex normals and calculate them if not</li><li>move every vertex one unit length along its normal direction</li><li>print the resulting positions to std::cout</li></ol>
<p>
Let's start with adding vertex normals to the mesh:<p>
 <div class="fragment"><pre class="fragment">  mesh.request_vertex_normals();
</pre></div><p>
In a similar manner we can request the other standard properties. For example the face normals:<p>
<div class="fragment"><pre class="fragment">    mesh.request_face_normals();
</pre></div><p>
We need them to calculate the vertex normals with <code>update_normals()</code>, if the file didn't provide any.<p>
But we can do more with standard properties. We can verify if the mesh has already the property vertex normals<p>
 <div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (!mesh.has_vertex_normals())
  {
    std::cerr &lt;&lt; <span class="stringliteral">"ERROR: Standard vertex property 'Normals' not available!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }
</pre></div><p>
And after usage we remove them again<p>
<div class="fragment"><pre class="fragment">  mesh.release_vertex_normals();
</pre></div><p>
But, what happens if for example the vertex status property has been requested twice? Then the first release does nothing, but the second one will remove it. The standard properties have a reference counter, which is incremented by one for each request and decremented by one for each release. Iff the counter reaches 0 the property will be removed from memory.<p>
Now we know how to add and remove standard properties, but how do we access them? Again we need the mesh object. Unlike the custom properties, where we accessed one with the mesh member function <code>property()</code>, for each standard property the mesh provides a get and a set method. We have used one pair of get/set methods already in the previous three tutorials, where we computed a new location for the vertex position. Here we move all vertices a unit length along their normal direction:<p>
 <div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a> v_it = mesh.vertices_begin();
       v_it != mesh.vertices_end(); ++v_it)
  {
    mesh.set_point( v_it, mesh.point(v_it)+mesh.normal(v_it) );
  }
</pre></div><p>
The get-methods take an entity handle and return the value of the desired property, and the set-methods requires an additional parameter to pass the new value to the propertery. According to the table not every pair of get/set-methods apply to every entity. For example a face has normally no texture coordinates, hence a call to <code>mesh.texcoord( _face_handle )</code> will result in an error when compiling the code.<p>
Since we know how to add/remove/access standard properties, one further question remains. What data types do they have? And are there more hidden secrets? The next tutorial (<a class="el" href="tutorial_06.html">Using mesh traits and attributes</a>) will give the answer.<p>
The complete source looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="comment">// --------------------</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>


<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html">OpenMesh::TriMesh_ArrayKernelT&lt;&gt;</a>  MyMesh;


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;

  <span class="keywordflow">if</span> (argc!=2)
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Usage: properties &lt;input&gt;\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// request vertex normals, so the mesh reader can use normal information</span>
  <span class="comment">// if available</span>
  mesh.request_vertex_normals();

  <span class="comment">// assure we have vertex normals</span>
  <span class="keywordflow">if</span> (!mesh.has_vertex_normals())
  {
    std::cerr &lt;&lt; <span class="stringliteral">"ERROR: Standard vertex property 'Normals' not available!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <a class="code" href="classOpenMesh_1_1IO_1_1Options.html">OpenMesh::IO::Options</a> opt;
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#d5533287a322aab83c19ea93ed626ae1">OpenMesh::IO::read_mesh</a>(mesh,argv[1], opt))
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error loading mesh from file "</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// If the file did not provide vertex normals, then calculate them</span>
  <span class="keywordflow">if</span> ( !opt.<a class="code" href="classOpenMesh_1_1IO_1_1Options.html#b29ad02b981bdf64d70f562093a8df27">check</a>( <a class="code" href="classOpenMesh_1_1IO_1_1Options.html#040ea9de4824f79bb2331a8783243247816fe76469be54841546944f847e92cd">OpenMesh::IO::Options::VertexNormal</a> ) )
  {
    <span class="comment">// we need face normals to update the vertex normals</span>
    mesh.request_face_normals();

    <span class="comment">// let the mesh update the normals</span>
    mesh.update_normals();

    <span class="comment">// dispose the face normals, as we don't need them anymore</span>
    mesh.release_face_normals();
  }

  <span class="comment">// move all vertices one unit length along it's normal direction</span>
  <span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a> v_it = mesh.vertices_begin();
       v_it != mesh.vertices_end(); ++v_it)
  {
    std::cout &lt;&lt; <span class="stringliteral">"Vertex #"</span> &lt;&lt; v_it &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; mesh.point( v_it );
    mesh.set_point( v_it, mesh.point(v_it)+mesh.normal(v_it) );
    std::cout &lt;&lt; <span class="stringliteral">" moved to "</span> &lt;&lt; mesh.point( v_it ) &lt;&lt; std::endl;
  }

  <span class="comment">// don't need the normals anymore? Remove them!</span>
  mesh.release_vertex_normals();

  <span class="comment">// just check if it really works</span>
  <span class="keywordflow">if</span> (mesh.has_vertex_normals())
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Ouch! ERROR! Shouldn't have any vertex normals anymore!\n"</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

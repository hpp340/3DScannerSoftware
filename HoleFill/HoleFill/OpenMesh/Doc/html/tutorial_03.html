<html>
    <head>
      <title>OpenMesh: Using (custom) properites</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial_03">Using (custom) properites</a></h1>This examples shows:<ul>
<li>How to add and remove custom properties,</li><li>How to get and set the value of a custom property</li></ul>
<p>
In the last example we computed the barycenter of each vertex' neighborhood and stored it in an array. It would be more convenient and less error-prone if we could store this data in the mesh and let OpenMesh manage the data. It would be even more helpful if we could attach such properties dynamically to the mesh.<p>
OpenMesh provides dynamic properties, which can be attached to each mesh entity (vertex, face, edge, halfedge, and the mesh itself). We distinguish between custom and standard properties. A custom property is any user-defined property and is accessed via the member function <code>property</code>(..), a handle and an entity handle (e.g. VertexHandle). Whereas the standard properties are accessed via special member functions, e.g. the vertex position is accessed with <code>point</code>(..) and a vertex handle.<p>
In this example we will store the <code>cog-value</code> (see previous example) in an additional vertex property instead of keeping it in a separate array. To do so we define first a so-called property handle with the desired type (<code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a></code>) and register the handle at the mesh:<p>
 <div class="fragment"><pre class="fragment">  <span class="comment">// this vertex property stores the computed centers of gravity</span>
  <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt;MyMesh::Point&gt;</a> cogs;
  mesh.add_property(cogs);
</pre></div><p>
<br>
The <code>mesh</code> allocates enough memory to hold as many elements of type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a></code> as number of vertices exist, and of course the mesh synchronizes all insert and delete operations on the vertices with the vertex properties.<p>
Once the wanted property is registered we can use the property to calculate the barycenter of the neighborhood of each vertex <code>v_it</code> <p>
 <div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (vv_it=mesh.vv_iter( v_it ); vv_it; ++vv_it)
      {
        mesh.property(cogs,v_it) += mesh.point( vv_it );
        ++valence;
      }
      mesh.property(cogs,v_it) /= valence;
</pre></div><p>
<br>
and finally set the new position for each vertex <code>v_it</code> <p>
 <div class="fragment"><pre class="fragment">        mesh.set_point( v_it, mesh.property(cogs,v_it) );
</pre></div><p>
<br>
Below is the complete source code:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="comment">// --------------------</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>

<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html">OpenMesh::TriMesh_ArrayKernelT&lt;&gt;</a>  MyMesh;


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;


  <span class="comment">// check command line options</span>
  <span class="keywordflow">if</span> (argc != 4) 
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Usage:  "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" #iterations infile outfile\n"</span>;
    <span class="keywordflow">return</span> 1;
  }



  <span class="comment">// read mesh from stdin</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#d5533287a322aab83c19ea93ed626ae1">OpenMesh::IO::read_mesh</a>(mesh, argv[2]) )
  {
     std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read mesh from "</span> &lt;&lt; argv[2] &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
  }



  <span class="comment">// this vertex property stores the computed centers of gravity</span>
  <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt;MyMesh::Point&gt;</a> cogs;
  mesh.add_property(cogs);

  <span class="comment">// smoothing mesh argv[1] times</span>
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a>          v_it, v_end(mesh.vertices_end());
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#baf5c380a6bdaf90b945515aa8e2eefb">MyMesh::VertexVertexIter</a>    vv_it;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#076fb26bbcdd0b24019ddea5fef98efd">MyMesh::Point</a>               cog;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#f9e609f25989239b717eecdc385c9f7d">MyMesh::Scalar</a>              valence;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i, N(atoi(argv[1]));

  
  <span class="keywordflow">for</span> (i=0; i &lt; N; ++i)
  {
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
    {      
      mesh.property(cogs,v_it).vectorize(0.0f);
      valence = 0;
      
      <span class="keywordflow">for</span> (vv_it=mesh.vv_iter( v_it ); vv_it; ++vv_it)
      {
        mesh.property(cogs,v_it) += mesh.point( vv_it );
        ++valence;
      }
      mesh.property(cogs,v_it) /= valence;
    }
    
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
      <span class="keywordflow">if</span> ( !mesh.is_boundary( v_it ) )
        mesh.set_point( v_it, mesh.property(cogs,v_it) );
  }


  <span class="comment">// write mesh to stdout</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#696d75fb5550b5d1dadfd0aebe1468ec">OpenMesh::IO::write_mesh</a>(mesh, argv[3]) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot write mesh to "</span> &lt;&lt; argv[3] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

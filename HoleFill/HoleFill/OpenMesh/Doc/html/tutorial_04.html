<html>
    <head>
      <title>OpenMesh: Using STL algorithms</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial_04">Using STL algorithms</a></h1>Since the OpenMesh iterators are (almost) conformant to STL iterators, one can apply the STL algorithms on meshes.<p>
The following example shows how to use the STL <code>for_each</code> construct, since it is easier to read and may be more efficient than hand-written loops.<p>
We will define a class which provides the smoothing algorithm, hence define a reusable component. The class must be template class because there is no such thing as a class OpenMesh, but many different types of OpenMesh:<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh&gt; <span class="keyword">class </span>SmootherT
</pre></div><p>
The class SmootherT has two functors, one that computes the barycenter for a given vertex, and a second that sets the vertex position to the corresponding barycenter. A functor is simply a class with a function <code>operator()(...)</code>. The first functor <code>ComputeCOG</code> computes the barycenter and store it in a custom vertex property <code>cog_:</code> <p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle      vh( mesh_.handle(_v) );
      <span class="keyword">typename</span> Mesh::VertexVertexIter  vv_it;
      <span class="keyword">typename</span> Mesh::Scalar            valence(0.0);
    
      mesh_.property(cog_, vh) = <span class="keyword">typename</span> Mesh::Point(0.0, 0.0, 0.0);

      <span class="keywordflow">for</span> (vv_it=mesh_.vv_iter(vh); vv_it; ++vv_it)
      {
        mesh_.property(cog_, vh) += mesh_.point( vv_it );
        ++valence;
      }

      mesh_.property(cog_, mesh_.handle(_v) ) /= valence;
    }
</pre></div><p>
Note, that <code>ComputeCOG</code> needs to have access to the mesh object and the property handle. Here, both are references to member variables of the smoother object.<p>
The second functor <code>class</code> <code>SetCOG</code>, which sets the vertex position, is constructed analogical.<p>
Using these functors and <code>std::for_each</code> from the STL the smoothing algorithm can be realized in a member function of <code>SmootherT:</code> <p>
 <div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> smooth(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _iterations)
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; _iterations; ++i)
    {
      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    ComputeCOG(mesh_, cog_));

      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    SetCOG(mesh_, cog_));
    }
  }
</pre></div><p>
<br>
The complete example looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Utils/Property.hh&gt;</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh&gt; <span class="keyword">class </span>SmootherT
{
<span class="keyword">public</span>:

  <span class="keyword">typedef</span> <span class="keyword">typename</span> Mesh::Point            cog_t;
  <span class="keyword">typedef</span> <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt; cog_t &gt;</a> Property_cog;

<span class="keyword">public</span>:

  <span class="comment">// construct with a given mesh</span>
  SmootherT(Mesh&amp; _mesh) 
    : mesh_(_mesh)
  { 
    mesh_.add_property( cog_ );
  }

  ~SmootherT()
  {
    mesh_.remove_property( cog_ );
  }

  <span class="comment">// smooth mesh _iterations times</span>
  <span class="keywordtype">void</span> smooth(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _iterations)
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; _iterations; ++i)
    {
      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    ComputeCOG(mesh_, cog_));

      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    SetCOG(mesh_, cog_));
    }
  }


<span class="keyword">private</span>:


  <span class="comment">//--- private classes ---</span>

  <span class="keyword">class </span>ComputeCOG
  {
  <span class="keyword">public</span>:
    ComputeCOG(Mesh&amp; _mesh, Property_cog&amp; _cog) 
      : mesh_(_mesh), cog_(_cog)
    {}

    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle      vh( mesh_.handle(_v) );
      <span class="keyword">typename</span> Mesh::VertexVertexIter  vv_it;
      <span class="keyword">typename</span> Mesh::Scalar            valence(0.0);
    
      mesh_.property(cog_, vh) = <span class="keyword">typename</span> Mesh::Point(0.0, 0.0, 0.0);

      <span class="keywordflow">for</span> (vv_it=mesh_.vv_iter(vh); vv_it; ++vv_it)
      {
        mesh_.property(cog_, vh) += mesh_.point( vv_it );
        ++valence;
      }

      mesh_.property(cog_, mesh_.handle(_v) ) /= valence;
    }

  <span class="keyword">private</span>:
    Mesh&amp;         mesh_;
    Property_cog&amp; cog_;
  };


  <span class="keyword">class </span>SetCOG
  {
  <span class="keyword">public</span>:
    SetCOG(Mesh&amp; _mesh, Property_cog&amp; _cog) 
      : mesh_(_mesh), cog_(_cog)
    {}

    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle vh(mesh_.handle(_v));

      <span class="keywordflow">if</span> (!mesh_.is_boundary(vh))
        mesh_.set_point( vh, mesh_.property(cog_, vh) );
    }

  <span class="keyword">private</span>:

    Mesh&amp;         mesh_;
    Property_cog&amp; cog_;
  };


  <span class="comment">//--- private elements ---</span>

  Mesh&amp;        mesh_;
  Property_cog cog_;
};

<span class="preprocessor">#endif</span>
</pre></div><p>
<br>
and<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="comment">// -------------------- OpenMesh</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/Types/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="comment">// -------------------- </span>
<span class="preprocessor">#include "smooth_algo.hh"</span>


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#2f7526fd98f8939feedb0edc9f430794">HalfedgeAttributes</a>(<a class="code" href="namespaceOpenMesh_1_1Attributes.html#2f3bf31d2662e93633f25bf81e6adc3698cca64c8972265b612cb15552bc82ed">OpenMesh::Attributes::PrevHalfedge</a>);
};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;


  <span class="comment">// check command line options</span>
  <span class="keywordflow">if</span> (argc != 4) 
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Usage:  "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" #iterations  infile  outfile\n"</span>;
    <span class="keywordflow">return</span> 1;
  }


  <span class="comment">// read mesh from stdin</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#d5533287a322aab83c19ea93ed626ae1">OpenMesh::IO::read_mesh</a>(mesh, argv[2]) )
  {
     std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read mesh from "</span> &lt;&lt; argv[2] &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
  }


  <span class="comment">// smoothing mesh argv[1] times</span>
  SmootherT&lt;MyMesh&gt; smoother(mesh);
  smoother.smooth(atoi(argv[1]));


  <span class="comment">// write mesh to stdout</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#696d75fb5550b5d1dadfd0aebe1468ec">OpenMesh::IO::write_mesh</a>(mesh, argv[3]) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot write mesh to "</span> &lt;&lt; argv[3] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }
  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>

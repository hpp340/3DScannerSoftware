<html>
    <head>
      <title>OpenMesh: Mesh Iterators and Circulators</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="mesh_iterators">Mesh Iterators and Circulators</a></h1>The mesh provides linear iterators (that enumerate vertices, halfedges, edges, and faces) and so called circulators (to iterate <em>around</em> a vertex or a face).<p>
These can be used to easily navigate through a mesh. Each iterator <code>XYZIter</code> also exists in a const version <code>ConstXYZIter</code>.<p>
All iterators and circulators are defined in the namespace <a class="el" href="namespaceOpenMesh_1_1Iterators.html">OpenMesh::Iterators</a>. They are template classes that expect a mesh as template argument to be fully specified. You should use the iterator/circulator types provided by the mesh itself, i.e. <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a></code> instead of <code>OpenMesh::Iterators::VertexIterT&lt;MyMesh&gt;</code>.<p>
The linear iterators are used to enumerate all mesh items, e.g. for rendering purposes. The iterators and their <code>const</code> counterparts are:<p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

<span class="comment">// iterate over all vertices</span>
<span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a> v_it=mesh.vertices_begin(); v_it!=mesh.vertices_end(); ++v_it) 
   ...; <span class="comment">// do something with *v_it, v_it-&gt;, or v_it.handle()</span>

<span class="comment">// iterate over all halfedges</span>
<span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#8c84580a2b1b0946c9fb0193b478055b">MyMesh::HalfedgeIter</a> h_it=mesh.halfedges_begin(); v_it!=mesh.halfedges_end(); ++v_it) 
   ...; <span class="comment">// do something with *h_it, h_it-&gt;, or h_it.handle()</span>

<span class="comment">// iterate over all edges</span>
<span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#ee2aa18ba6591ba930e7f03704caf7ea">MyMesh::EdgeIter</a> e_it=mesh.edges_begin(); v_it!=mesh.edges_end(); ++v_it) 
   ...; <span class="comment">// do something with *e_it, e_it-&gt;, or e_it.handle()</span>

<span class="comment">// iterator over all faces</span>
<span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#14780ae50868e71a8f6acfa01ccd4e00">MyMesh::FaceIter</a> f_it=mesh.faces_begin(); v_it!=mesh.faces_end(); ++v_it) 
   ...; <span class="comment">// do something with *f_it, f_it-&gt;, or f_it.handle()</span>

</pre></div><p>
The corresponding <code>const</code> counterparts are<p>
<ul>
<li><code>ConstVertexIter</code>, </li>
<li><code>ConstHalfedgeIter</code>, </li>
<li><code>ConstEdgeIter</code>, </li>
<li><code>ConstFaceIter</code>.</li>
</ul>
The linear iterators are (almost) conformant to STL iterators. For a description of their interface see OpenMesh::Concepts::IteratorT.<p>
For efficiency reasons the <code>operation++</code>(int) (post-increment) and <code>operation--</code>(int) (post-decrement) are not implemented. Additionally to the standard operations, each linear iterator provides a method <code>handle()</code>, which returns the handle of the item referred to by the iterator.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>An iterator to an item usually needs more memory than a handle of an item. To store many references to an item, it is therefore better to use handles.</dd></dl>
<br>
<br>
 <p>
Circulators provide means to enumerate items adjacent to another item of the same or another type. For example, a <code>VertexVertexIter</code> allows to enumerate all vertices immediately adjacent to a (center) vertex (i.e. it allows to enumerate the so-called 1-ring of the center vertex). Analogously, a <code>FaceHalfedgeIter</code> enumerates all the halfedges belonging to a face. In general, <code>CenterItem_AuxiliaryInformation_TargetItem_Iter</code> designates a circulator that enumarates all the target items around a given center item.<p>
The circulators around a vertex are:<p>
<ul>
<li><code>VertexVertexIter:</code> iterate over all neighboring vertices. </li>
<li><code>VertexIHalfedgeIter:</code> iterate over all <em>incoming</em> halfedges. </li>
<li><code>VertexOHalfedgeIter:</code> iterate over all <em>outgoing</em> halfedges. </li>
<li><code>VertexEdgeIter:</code> iterate over all incident edges. </li>
<li><code>VertexFaceIter:</code> iterate over all adjacent faces.</li>
</ul>
The circulators around a face are:<p>
<ul>
<li><code>FaceVertexIter:</code> iterate over the face's vertices. </li>
<li><code>FaceHalfedgeIter:</code> iterate over the face's halfedges. </li>
<li><code>FaceEdgeIter:</code> iterate over the face's edges. </li>
<li><code>FaceFaceIter:</code> iterate over all edge-neighboring faces.</li>
</ul>
The constructor of a circulator is of the form <code>Circulator(MeshType mesh, TargetHandle center_handle)</code>, i.e. it takes a mesh and the handle of the item to iterate around.<p>
All circulators provide the operations listed in OpenMesh::Concepts::CirculatorT, which are basically the same as the iterator funtions.<p>
Furthermore, circulators provide <code>operator \c bool()</code>, which returns true, as long as the circulator hasn't reached the end of the sequence.<p>
Example: The following code enumerates the 1-ring of each vertex:<p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

<span class="comment">// (linearly) iterate over all vertices</span>
<span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#2f1cfb280596c6d96fb4e94175c196ff">MyMesh::VertexIter</a> v_it=mesh.vertices_begin(); v_it!=mesh.vertices_end(); ++v_it)
{
  <span class="comment">// circulate around the current vertex</span>
  <span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#baf5c380a6bdaf90b945515aa8e2eefb">MyMesh::VertexVertexIter</a> vv_it=mesh.vv_iter(v_it.handle()); vv_it; ++vv_it)
  {
    <span class="comment">// do something with e.g. mesh.point(*vv_it)</span>
  }
}
</pre></div> <hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
